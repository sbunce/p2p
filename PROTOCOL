PROTOCOL DOCUMENTATION

/******************************************************************************/
DOCUMENT FORMAT

Command, Full Name
Direction (ie client -> server would indicate from the client to the server)
Description
Byte-Diagram
Possible Responses
Byte-Diagram for Possible Response

/******************************************************************************/
DEFINITIONS

ID  - Short for identification.
RRN - relative record number (determines a byte offset when multiplied by a
      block size).

/******************************************************************************/
GENERAL PROTOCOL INFORMATION

All encoded numbers are unsigned and are in network byte order, or big endian.

Requests to the server are pipelined. The maximum number of unresponded to
commands which can be sent is global::PIPELINE_SIZE. If more than this number
of requests is sent the client will be considered abusive and disconnected. To
maximize performance global::PIPELINE_SIZE requests are sent upon download start
and a new request is sent every time a response is received.

/******************************************************************************/

P_SBL, Send Block
client -> server

Request a file block from the server by sending the file ID and RRN of the block.

	  0   1   2   3   4   6   7   8   9
	+---+---+---+---+---+---+---+---+---+
	| C |    file ID    |      RRN      |
	+---+---+---+---+---+---+---+---+---+

Possible Responses:

P_BLS, Block Send

The server is sending us the block requested.

	  0   1   2   3   .........  8192
	+---+---+---+---+---+---+---+---+
	| C |        file block         |
	+---+---+---+---+---+---+---+---+


P_DNE, Block Does Not Exist

The server sends this when it is in progress of downloading the file but doesn't
yet have the block requested.

	  0
	+---+
	| C |
	+---+


P_FNF, File Not Found

The server doesn't have the requested file.

	  0
	+---+
	| C |
	+---+

/******************************************************************************/
RE-REQUEST ALGORITHM

A server may be extremely slow or disconnected but not timed out. If either of
these happen it's necessary to re-request the blocks expected from the tardy
server.

The re-request algorithm is based on buffer size and scales with how many servers
the download_file is connected to. Re-requests are linear and will done when:

	B mod(Q) = 0 , where B is the buffer size and

	Q = C * R , where
	            C is the number of servers that are sending blocks
	            R is the re-request factor (constant)

This has the problem of checking extra times when the number of connected
servers fluctuates. For example say there is a check, and right after that another
server is connected, then a check will be done after R more blocks are received.

Re-requests are done from servers that hadn't already had the late block
requested from it.


NOT COMPLETED

/******************************************************************************/
PIPELINING (AKA WINDOWING)

Pipelining is done to avoid dead time (time where no data is being transferred).
Dead time happens with "stop-n-go" protocols where a client will only send a new
request when the response to the previous request is gotten. Pipelining solves
this by having the client send out many requests initially, and then sending
new requests as responses are received. In this way the server maintains a queue
of requests it can process even if new requests are delayed.

Pipelining in this program is done in the client_buffer class to hide most of
the complexity from the downloads. The only requirement for downloads is
that they maintain their own request queues such that they can provide the
client buffer with multiple requests before the client_buffer returns any
responses.

